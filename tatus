[1mdiff --git a/README.md b/README.md[m
[1mindex fe00755..9dc5dc2 100644[m
[1m--- a/README.md[m
[1m+++ b/README.md[m
[36m@@ -1,4 +1,4 @@[m
[31m-# DingTalk Channel for OpenClaw [m
[32m+[m[32m# DingTalk Channel for OpenClaw[m
 [m
 é’‰é’‰ä¼ä¸šå†…éƒ¨æœºå™¨äºº Channel æ’ä»¶ï¼Œä½¿ç”¨ Stream æ¨¡å¼ï¼ˆæ— éœ€å…¬ç½‘ IPï¼‰ã€‚[m
 [m
[36m@@ -8,6 +8,7 @@[m
 - âœ… **ç§èŠæ”¯æŒ** â€” ç›´æ¥ä¸æœºå™¨äººå¯¹è¯[m
 - âœ… **ç¾¤èŠæ”¯æŒ** â€” åœ¨ç¾¤é‡Œ @æœºå™¨äºº[m
 - âœ… **å¤šç§æ¶ˆæ¯ç±»å‹** â€” æ–‡æœ¬ã€å›¾ç‰‡ã€è¯­éŸ³ï¼ˆè‡ªå¸¦è¯†åˆ«ï¼‰ã€è§†é¢‘ã€æ–‡ä»¶[m
[32m+[m[32m- âœ… **æ–‡ä»¶å‘é€** â€” æ”¯æŒå‘é€å„ç±»æ–‡ä»¶ï¼ˆæ–‡æ¡£ã€å›¾ç‰‡ã€éŸ³è§†é¢‘ç­‰ï¼‰[m
 - âœ… **Markdown å›å¤** â€” æ”¯æŒå¯Œæ–‡æœ¬æ ¼å¼å›å¤[m
 - âœ… **äº’åŠ¨å¡ç‰‡** â€” æ”¯æŒæµå¼æ›´æ–°ï¼Œé€‚ç”¨äº AI å®æ—¶è¾“å‡º[m
 - âœ… **å®Œæ•´ AI å¯¹è¯** â€” æ¥å…¥ Clawdbot æ¶ˆæ¯å¤„ç†ç®¡é“[m
[36m@@ -67,6 +68,7 @@[m [mopenclaw plugins install -l .[m
 ### 3. é…ç½® Clawdbot[m
 [m
 åœ¨ `~/.openclaw/clawdbot.json` çš„ `channels` ä¸‹æ·»åŠ ï¼š[m
[32m+[m
 > åªæ·»åŠ dingtalkéƒ¨åˆ†ï¼Œå†…å®¹è‡ªå·±æ›¿æ¢[m
 [m
 ```json5[m
[36m@@ -83,8 +85,8 @@[m [mopenclaw plugins install -l .[m
       "corpId": "dingxxxxxx",[m
       "agentId": "123456789",[m
       "dmPolicy": "open",[m
[31m-      "groupPolicy": "open",      [m
[31m-      "messageType": "markdown",       [m
[32m+[m[32m      "groupPolicy": "open",[m
[32m+[m[32m      "messageType": "markdown",[m
       "debug": false[m
     }[m
   },[m
[36m@@ -100,22 +102,22 @@[m [mopenclaw gateway restart[m
 [m
 ## é…ç½®é€‰é¡¹[m
 [m
[31m-| é€‰é¡¹               | ç±»å‹     | é»˜è®¤å€¼                                                          | è¯´æ˜                                      |[m
[31m-| ------------------ | -------- | --------------------------------------------------------------- | ----------------------------------------- |[m
[31m-| `enabled`          | boolean  | `true`                                                          | æ˜¯å¦å¯ç”¨                                  |[m
[31m-| `clientId`         | string   | å¿…å¡«                                                            | åº”ç”¨çš„ AppKey                             |[m
[31m-| `clientSecret`     | string   | å¿…å¡«                                                            | åº”ç”¨çš„ AppSecret                          |[m
[31m-| `robotCode`        | string   | -                                                               | æœºå™¨äººä»£ç ï¼ˆç”¨äºä¸‹è½½åª’ä½“å’Œå‘é€å¡ç‰‡ï¼‰      |[m
[31m-| `corpId`           | string   | -                                                               | ä¼ä¸š ID                                   |[m
[31m-| `agentId`          | string   | -                                                               | åº”ç”¨ ID                                   |[m
[31m-| `dmPolicy`         | string   | `"open"`                                                        | ç§èŠç­–ç•¥ï¼šopen/pairing/allowlist          |[m
[31m-| `groupPolicy`      | string   | `"open"`                                                        | ç¾¤èŠç­–ç•¥ï¼šopen/allowlist                  |[m
[31m-| `allowFrom`        | string[] | `[]`                                                            | å…è®¸çš„å‘é€è€… ID åˆ—è¡¨                      |[m
[31m-| `messageType`      | string   | `"markdown"`                                                    | æ¶ˆæ¯ç±»å‹ï¼štext/markdown/card              |[m
[31m-| `cardTemplateId`   | string   | `"StandardCard"`                                                | äº’åŠ¨å¡ç‰‡æ¨¡æ¿ IDï¼ˆä»…å½“ messageType=cardï¼‰  |[m
[31m-| `cardSendApiUrl`   | string   | `"https://api.dingtalk.com/v1.0/im/v1.0/robot/interactiveCards/send"` | è‡ªå®šä¹‰å¡ç‰‡å‘é€ API URLï¼ˆå¯é€‰ï¼‰            |[m
[31m-| `cardUpdateApiUrl` | string   | `"https://api.dingtalk.com/v1.0/im/robots/interactiveCards"`   | è‡ªå®šä¹‰å¡ç‰‡æ›´æ–° API URLï¼ˆå¯é€‰ï¼‰            |[m
[31m-| `debug`            | boolean  | `false`                                                         | æ˜¯å¦å¼€å¯è°ƒè¯•æ—¥å¿—                          |[m
[32m+[m[32m| é€‰é¡¹               | ç±»å‹     | é»˜è®¤å€¼                                                                | è¯´æ˜                                     |[m
[32m+[m[32m| ------------------ | -------- | --------------------------------------------------------------------- | ---------------------------------------- |[m
[32m+[m[32m| `enabled`          | boolean  | `true`                                                                | æ˜¯å¦å¯ç”¨                                 |[m
[32m+[m[32m| `clientId`         | string   | å¿…å¡«                                                                  | åº”ç”¨çš„ AppKey                            |[m
[32m+[m[32m| `clientSecret`     | string   | å¿…å¡«                                                                  | åº”ç”¨çš„ AppSecret                         |[m
[32m+[m[32m| `robotCode`        | string   | -                                                                     | æœºå™¨äººä»£ç ï¼ˆç”¨äºä¸‹è½½åª’ä½“å’Œå‘é€å¡ç‰‡ï¼‰     |[m
[32m+[m[32m| `corpId`           | string   | -                                                                     | ä¼ä¸š ID                                  |[m
[32m+[m[32m| `agentId`          | string   | -                                                                     | åº”ç”¨ ID                                  |[m
[32m+[m[32m| `dmPolicy`         | string   | `"open"`                                                              | ç§èŠç­–ç•¥ï¼šopen/pairing/allowlist         |[m
[32m+[m[32m| `groupPolicy`      | string   | `"open"`                                                              | ç¾¤èŠç­–ç•¥ï¼šopen/allowlist                 |[m
[32m+[m[32m| `allowFrom`        | string[] | `[]`                                                                  | å…è®¸çš„å‘é€è€… ID åˆ—è¡¨                     |[m
[32m+[m[32m| `messageType`      | string   | `"markdown"`                                                          | æ¶ˆæ¯ç±»å‹ï¼štext/markdown/card             |[m
[32m+[m[32m| `cardTemplateId`   | string   | `"StandardCard"`                                                      | äº’åŠ¨å¡ç‰‡æ¨¡æ¿ IDï¼ˆä»…å½“ messageType=cardï¼‰ |[m
[32m+[m[32m| `cardSendApiUrl`   | string   | `"https://api.dingtalk.com/v1.0/im/v1.0/robot/interactiveCards/send"` | è‡ªå®šä¹‰å¡ç‰‡å‘é€ API URLï¼ˆå¯é€‰ï¼‰           |[m
[32m+[m[32m| `cardUpdateApiUrl` | string   | `"https://api.dingtalk.com/v1.0/im/robots/interactiveCards"`          | è‡ªå®šä¹‰å¡ç‰‡æ›´æ–° API URLï¼ˆå¯é€‰ï¼‰           |[m
[32m+[m[32m| `debug`            | boolean  | `false`                                                               | æ˜¯å¦å¼€å¯è°ƒè¯•æ—¥å¿—                         |[m
 [m
 ## å®‰å…¨ç­–ç•¥[m
 [m
[36m@@ -145,28 +147,34 @@[m [mopenclaw gateway restart[m
 [m
 ### å‘é€[m
 [m
[31m-| ç±»å‹         | æ”¯æŒ | è¯´æ˜                                       |[m
[31m-| ------------ | ---- | ------------------------------------------ |[m
[31m-| æ–‡æœ¬         | âœ…   | å®Œæ•´æ”¯æŒ                                   |[m
[31m-| Markdown     | âœ…   | è‡ªåŠ¨æ£€æµ‹æˆ–æ‰‹åŠ¨æŒ‡å®š                         |[m
[31m-| äº’åŠ¨å¡ç‰‡     | âœ…   | æ”¯æŒæµå¼æ›´æ–°ï¼Œé€‚ç”¨äº AI å®æ—¶è¾“å‡º           |[m
[31m-| å›¾ç‰‡         | â³   | éœ€è¦é€šè¿‡åª’ä½“ä¸Šä¼  API                       |[m
[32m+[m[32m| ç±»å‹     | æ”¯æŒ | è¯´æ˜                                     |[m
[32m+[m[32m| -------- | ---- | ---------------------------------------- |[m
[32m+[m[32m| æ–‡æœ¬     | âœ…   | å®Œæ•´æ”¯æŒ                                 |[m
[32m+[m[32m| Markdown | âœ…   | è‡ªåŠ¨æ£€æµ‹æˆ–æ‰‹åŠ¨æŒ‡å®š                       |[m
[32m+[m[32m| äº’åŠ¨å¡ç‰‡ | âœ…   | æ”¯æŒæµå¼æ›´æ–°ï¼Œé€‚ç”¨äº AI å®æ—¶è¾“å‡º         |[m
[32m+[m[32m| æ–‡ä»¶     | âœ…   | æ”¯æŒå‘é€å„ç±»æ–‡ä»¶ï¼ˆæ–‡æ¡£ã€å›¾ç‰‡ã€éŸ³è§†é¢‘ç­‰ï¼‰ |[m
[32m+[m[32m| å›¾ç‰‡     | âœ…   | é€šè¿‡åª’ä½“ä¸Šä¼  API å‘é€                    |[m
[32m+[m[32m| éŸ³é¢‘     | âœ…   | é€šè¿‡åª’ä½“ä¸Šä¼  API å‘é€                    |[m
[32m+[m[32m| è§†é¢‘     | âœ…   | é€šè¿‡åª’ä½“ä¸Šä¼  API å‘é€                    |[m
 [m
 ## æ¶ˆæ¯ç±»å‹é€‰æ‹©[m
 [m
 æ’ä»¶æ”¯æŒä¸‰ç§æ¶ˆæ¯å›å¤ç±»å‹ï¼Œå¯é€šè¿‡ `messageType` é…ç½®ï¼š[m
 [m
 ### 1. textï¼ˆçº¯æ–‡æœ¬ï¼‰[m
[32m+[m
 - åŸºç¡€æ–‡æœ¬æ¶ˆæ¯[m
 - é€‚ç”¨äºç®€å•å›å¤[m
 - æ— æ ¼å¼åŒ–æ”¯æŒ[m
 [m
 ### 2. markdownï¼ˆMarkdown æ ¼å¼ï¼‰**ã€é»˜è®¤ã€‘**[m
[32m+[m
 - æ”¯æŒå¯Œæ–‡æœ¬æ ¼å¼ï¼ˆæ ‡é¢˜ã€ç²—ä½“ã€åˆ—è¡¨ç­‰ï¼‰[m
 - è‡ªåŠ¨æ£€æµ‹æ¶ˆæ¯æ˜¯å¦åŒ…å« Markdown è¯­æ³•[m
 - é€‚ç”¨äºå¤§å¤šæ•°åœºæ™¯[m
 [m
 ### 3. cardï¼ˆäº’åŠ¨å¡ç‰‡ï¼‰**ã€æ¨èç”¨äº AI å¯¹è¯ã€‘**[m
[32m+[m
 - æ”¯æŒæµå¼æ›´æ–°ï¼ˆå®æ—¶æ˜¾ç¤º AI ç”Ÿæˆå†…å®¹ï¼‰[m
 - æ›´å¥½çš„è§†è§‰å‘ˆç°[m
 - æ”¯æŒè‡ªå®šä¹‰å¡ç‰‡æ¨¡æ¿[m
[36m@@ -174,11 +182,13 @@[m [mopenclaw gateway restart[m
 [m
 **æµå¼æ›´æ–°ç¤ºä¾‹ï¼š**[m
 å½“é…ç½® `messageType: 'card'` æ—¶ï¼Œæœºå™¨äººä¼šï¼š[m
[32m+[m
 1. å‘é€åˆå§‹å¡ç‰‡æ˜¾ç¤º"æ­£åœ¨æ€è€ƒä¸­..."[m
 2. AI ç”Ÿæˆå›å¤æ—¶ï¼Œå®æ—¶æ›´æ–°å¡ç‰‡å†…å®¹[m
 3. ç”¨æˆ·å¯ä»¥çœ‹åˆ°å›å¤é€æ­¥ç”Ÿæˆçš„è¿‡ç¨‹[m
 [m
 **æµå¼æ›´æ–°ä¼˜åŒ–ï¼š**[m
[32m+[m
 - è‡ªåŠ¨èŠ‚æµï¼šæœ€å° 500ms æ›´æ–°é—´éš”ï¼Œé¿å… API é™æµ[m
 - è¶…æ—¶æ£€æµ‹ï¼š3 ç§’æ— æ›´æ–°è‡ªåŠ¨è§†ä¸ºå®Œæˆ[m
 - é”™è¯¯å¤„ç†ï¼šé‡åˆ° 404/410 é”™è¯¯è‡ªåŠ¨æ¸…ç†ç¼“å­˜[m
[36m@@ -192,6 +202,48 @@[m [mopenclaw gateway restart[m
 }[m
 ```[m
 [m
[32m+[m[32m## æ–‡ä»¶å‘é€[m
[32m+[m
[32m+[m[32mæ’ä»¶æ”¯æŒå‘é€å„ç§ç±»å‹çš„æ–‡ä»¶ï¼ŒåŒ…æ‹¬æ–‡æ¡£ã€å›¾ç‰‡ã€éŸ³é¢‘å’Œè§†é¢‘ã€‚[m
[32m+[m
[32m+[m[32m### å‘é€æ–‡ä»¶çš„æ–¹æ³•[m
[32m+[m
[32m+[m[32m#### 1. é€šè¿‡ Outbound API å‘é€[m
[32m+[m
[32m+[m[32m```bash[m
[32m+[m[32mopenclaw outbound send --channel dingtalk --to <conversationId> --media /path/to/file.pdf[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m#### 2. ä½¿ç”¨æ’ä»¶ API å‘é€[m
[32m+[m
[32m+[m[32m```typescript[m
[32m+[m[32mimport { uploadMedia, sendFileMessage, sendBySession } from '@openclaw/dingtalk';[m
[32m+[m
[32m+[m[32m// ä¸»åŠ¨å‘é€æ–‡ä»¶[m
[32m+[m[32mawait sendFileMessage(config, conversationId, '/path/to/file.pdf');[m
[32m+[m
[32m+[m[32m// åœ¨å¯¹è¯ä¸­å‘é€æ–‡ä»¶ï¼ˆå›å¤ï¼‰[m
[32m+[m[32mawait sendBySession(config, sessionWebhook, 'è¿™æ˜¯æ‚¨è¯·æ±‚çš„æ–‡ä»¶', '/path/to/file.pdf');[m
[32m+[m
[32m+[m[32m// åªä¸Šä¼ æ–‡ä»¶è·å– mediaId[m
[32m+[m[32mconst uploadResult = await uploadMedia(config, '/path/to/image.png', 'image');[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m#### 3. é€šè¿‡ OpenClaw æ¶ˆæ¯å¤„ç†å‘é€[m
[32m+[m
[32m+[m[32må½“ AI ç”Ÿæˆéœ€è¦å‘é€æ–‡ä»¶çš„å†…å®¹æ—¶ï¼ŒOpenClaw ä¼šè‡ªåŠ¨å¤„ç†æ–‡ä»¶å‘é€ã€‚[m
[32m+[m
[32m+[m[32m### æ”¯æŒçš„æ–‡ä»¶ç±»å‹[m
[32m+[m
[32m+[m[32m- **file**: æ™®é€šæ–‡ä»¶ï¼ˆæ–‡æ¡£ã€å‹ç¼©åŒ…ç­‰ï¼‰[m
[32m+[m[32m- **image**: å›¾ç‰‡æ–‡ä»¶ï¼ˆjpg, png, gif ç­‰ï¼‰[m
[32m+[m[32m- **audio**: éŸ³é¢‘æ–‡ä»¶ï¼ˆmp3, wav ç­‰ï¼‰[m
[32m+[m[32m- **video**: è§†é¢‘æ–‡ä»¶ï¼ˆmp4, avi ç­‰ï¼‰[m
[32m+[m
[32m+[m[32m### æ–‡ä»¶å‘é€ç¤ºä¾‹[m
[32m+[m
[32m+[m[32mæŸ¥çœ‹ [examples/file-sending-examples.ts](examples/file-sending-examples.ts) è·å–æ›´å¤šç¤ºä¾‹ä»£ç ã€‚[m
[32m+[m
 ## ä½¿ç”¨ç¤ºä¾‹[m
 [m
 é…ç½®å®Œæˆåï¼Œç›´æ¥åœ¨é’‰é’‰ä¸­ï¼š[m
[36m@@ -281,6 +333,12 @@[m [mDingTalkInboundMessage; // æ”¶åˆ°çš„é’‰é’‰æ¶ˆæ¯[m
 MessageContent; // è§£æåçš„æ¶ˆæ¯å†…å®¹[m
 HandleDingTalkMessageParams; // æ¶ˆæ¯å¤„ç†å‚æ•°[m
 [m
[32m+[m[32m// åª’ä½“æ–‡ä»¶[m
[32m+[m[32mMediaFile; // ä¸‹è½½çš„åª’ä½“æ–‡ä»¶[m
[32m+[m[32mMediaUploadResponse; // ä¸Šä¼ åª’ä½“æ–‡ä»¶çš„å“åº”[m
[32m+[m[32mFileMessageContent; // æ–‡ä»¶æ¶ˆæ¯å†…å®¹[m
[32m+[m[32mFileMessageWebhookResponse; // æ–‡ä»¶æ¶ˆæ¯ webhook å“åº”[m
[32m+[m
 // äº’åŠ¨å¡ç‰‡[m
 InteractiveCardData; // å¡ç‰‡æ•°æ®ç»“æ„[m
 InteractiveCardSendRequest; // å‘é€å¡ç‰‡è¯·æ±‚[m
[36m@@ -290,7 +348,7 @@[m [mCardInstance; // å¡ç‰‡å®ä¾‹ï¼ˆç”¨äºç¼“å­˜ï¼‰[m
 // å·¥å…·å‡½æ•°ç±»å‹[m
 Logger; // æ—¥å¿—æ¥å£[m
 RetryOptions; // é‡è¯•é€‰é¡¹[m
[31m-MediaFile; // ä¸‹è½½çš„åª’ä½“æ–‡ä»¶[m
[32m+[m[32mSendMessageOptions; // å‘é€æ¶ˆæ¯é€‰é¡¹[m
 ```[m
 [m
 ### å…¬å¼€ API[m
[36m@@ -300,8 +358,13 @@[m [mMediaFile; // ä¸‹è½½çš„åª’ä½“æ–‡ä»¶[m
 ```typescript[m
 // æ–‡æœ¬/Markdown æ¶ˆæ¯[m
 sendBySession(config, sessionWebhook, text, options); // é€šè¿‡ä¼šè¯å‘é€[m
[32m+[m[32msendBySession(config, sessionWebhook, text, mediaPath, options); // å‘é€æ–‡ä»¶[m
 sendProactiveMessage(config, target, text, options); // ä¸»åŠ¨å‘é€æ¶ˆæ¯[m
 [m
[32m+[m[32m// æ–‡ä»¶å‘é€[m
[32m+[m[32msendFileMessage(config, target, mediaPath, log); // å‘é€æ–‡ä»¶æ¶ˆæ¯[m
[32m+[m[32muploadMedia(config, mediaPath, mediaType, log); // ä¸Šä¼ æ–‡ä»¶è·å– mediaId[m
[32m+[m
 // äº’åŠ¨å¡ç‰‡ï¼ˆæµå¼æ›´æ–°ï¼‰[m
 sendInteractiveCard(config, conversationId, text, options); // å‘é€å¡ç‰‡[m
 updateInteractiveCard(config, cardBizId, text, options); // æ›´æ–°å¡ç‰‡[m
[36m@@ -316,7 +379,7 @@[m [mgetAccessToken(config, log); // è·å–è®¿é—®ä»¤ç‰Œ[m
 **ä½¿ç”¨ç¤ºä¾‹ï¼š**[m
 [m
 ```typescript[m
[31m-import { sendInteractiveCard, updateInteractiveCard } from './src/channel';[m
[32m+[m[32mimport { sendInteractiveCard, updateInteractiveCard, sendFileMessage, uploadMedia } from './src/channel';[m
 [m
 // å‘é€åˆå§‹å¡ç‰‡[m
 const { cardBizId } = await sendInteractiveCard(config, conversationId, 'æ­£åœ¨ç”Ÿæˆ...', {[m
[36m@@ -327,6 +390,13 @@[m [mconst { cardBizId } = await sendInteractiveCard(config, conversationId, 'æ­£åœ¨[m
 for (const chunk of aiResponseChunks) {[m
   await updateInteractiveCard(config, cardBizId, currentText + chunk, { log });[m
 }[m
[32m+[m
[32m+[m[32m// å‘é€æ–‡ä»¶æ¶ˆæ¯[m
[32m+[m[32mawait sendFileMessage(config, conversationId, '/path/to/file.pdf');[m
[32m+[m
[32m+[m[32m// ä¸Šä¼ æ–‡ä»¶è·å– mediaId[m
[32m+[m[32mconst uploadResult = await uploadMedia(config, '/path/to/image.png', 'image');[m
[32m+[m[32mconsole.log('mediaId:', uploadResult.mediaId);[m
 ```[m
 [m
 ### æ¶æ„[m
[1mdiff --git a/package.json b/package.json[m
[1mindex c64ebbc..9fb1859 100644[m
[1m--- a/package.json[m
[1m+++ b/package.json[m
[36m@@ -23,6 +23,7 @@[m
   "dependencies": {[m
     "axios": "^1.6.0",[m
     "dingtalk-stream": "^2.1.4",[m
[32m+[m[32m    "form-data": "^4.0.0",[m
     "zod": "^4.3.6"[m
   },[m
   "devDependencies": {[m
[36m@@ -88,4 +89,4 @@[m
       "defaultChoice": "local"[m
     }[m
   }[m
[31m-}[m
\ No newline at end of file[m
[32m+[m[32m}[m
[1mdiff --git a/src/channel.ts b/src/channel.ts[m
[1mindex 8308c45..9439f89 100644[m
[1m--- a/src/channel.ts[m
[1m+++ b/src/channel.ts[m
[36m@@ -4,6 +4,7 @@[m [mimport * as fs from 'node:fs';[m
 import * as path from 'node:path';[m
 import * as os from 'node:os';[m
 import { randomUUID } from 'node:crypto';[m
[32m+[m[32mimport FormData from 'form-data';[m
 import type { OpenClawConfig } from 'openclaw/plugin-sdk';[m
 import { buildChannelConfigSchema } from 'openclaw/plugin-sdk';[m
 import { maskSensitiveData, cleanupOrphanedTempFiles, retryWithBackoff } from '../utils';[m
[36m@@ -27,6 +28,8 @@[m [mimport type {[m
   InteractiveCardSendRequest,[m
   InteractiveCardUpdateRequest,[m
   CardInstance,[m
[32m+[m[32m  MediaUploadResponse,[m
[32m+[m[32m  FileMessageWebhookResponse,[m
 } from './types';[m
 [m
 // Access Token cache[m
[36m@@ -76,10 +79,7 @@[m [mfunction normalizeAllowFrom(list?: Array<string>): NormalizedAllowFrom {[m
 /**[m
  * Check if sender is allowed based on allowFrom list[m
  */[m
[31m-function isSenderAllowed(params: {[m
[31m-  allow: NormalizedAllowFrom;[m
[31m-  senderId?: string;[m
[31m-}): boolean {[m
[32m+[m[32mfunction isSenderAllowed(params: { allow: NormalizedAllowFrom; senderId?: string }): boolean {[m
   const { allow, senderId } = params;[m
   if (!allow.hasEntries) return true;[m
   if (allow.hasWildcard) return true;[m
[36m@@ -160,9 +160,13 @@[m [mfunction isConfigured(cfg: OpenClawConfig, accountId?: string): boolean {[m
 async function getAccessToken(config: DingTalkConfig, log?: Logger): Promise<string> {[m
   const now = Date.now();[m
   if (accessToken && accessTokenExpiry > now + 60000) {[m
[32m+[m[32m    log?.debug?.(`[DingTalk] Using cached access token (expires at: ${new Date(accessTokenExpiry).toISOString()})`);[m
     return accessToken;[m
   }[m
 [m
[32m+[m[32m  log?.info?.(`[DingTalk] Requesting new access token - clientId: ${config.clientId?.substring(0, 8)}...`);[m
[32m+[m[32m  log?.debug?.(`[DingTalk] Access token URL: https://api.dingtalk.com/v1.0/oauth2/accessToken`);[m
[32m+[m
   const token = await retryWithBackoff([m
     async () => {[m
       const response = await axios.post<TokenInfo>('https://api.dingtalk.com/v1.0/oauth2/accessToken', {[m
[36m@@ -170,8 +174,12 @@[m [masync function getAccessToken(config: DingTalkConfig, log?: Logger): Promise<str[m
         appSecret: config.clientSecret,[m
       });[m
 [m
[32m+[m[32m      log?.debug?.(`[DingTalk] Access token response - expireIn: ${response.data.expireIn} seconds`);[m
[32m+[m
       accessToken = response.data.accessToken;[m
       accessTokenExpiry = now + response.data.expireIn * 1000;[m
[32m+[m[32m      log?.info?.(`[DingTalk] New access token obtained, expires at: ${new Date(accessTokenExpiry).toISOString()}`);[m
[32m+[m
       return accessToken;[m
     },[m
     { maxRetries: 3, log }[m
[36m@@ -284,6 +292,138 @@[m [masync function downloadMedia(config: DingTalkConfig, downloadCode: string, log?:[m
   }[m
 }[m
 [m
[32m+[m[32m// Upload media file to DingTalk[m
[32m+[m[32masync function uploadMedia([m
[32m+[m[32m  config: DingTalkConfig,[m
[32m+[m[32m  mediaPath: string,[m
[32m+[m[32m  mediaType: string = 'file',[m
[32m+[m[32m  log?: Logger[m
[32m+[m[32m): Promise<MediaUploadResponse | null> {[m
[32m+[m[32m  try {[m
[32m+[m[32m    const fileName = path.basename(mediaPath);[m
[32m+[m[32m    const fileExt = fileName.split('.').pop()?.toLowerCase() || '';[m
[32m+[m
[32m+[m[32m    let finalMediaType = mediaType;[m
[32m+[m
[32m+[m[32m    if (mediaType === 'file') {[m
[32m+[m[32m      const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'bmp'];[m
[32m+[m[32m      const voiceExts = ['amr', 'mp3', 'wav'];[m
[32m+[m[32m      const videoExts = ['mp4'];[m
[32m+[m[32m      const fileExts = ['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'zip', 'pdf', 'rar'];[m
[32m+[m
[32m+[m[32m      if (imageExts.includes(fileExt)) {[m
[32m+[m[32m        finalMediaType = 'image';[m
[32m+[m[32m      } else if (voiceExts.includes(fileExt)) {[m
[32m+[m[32m        finalMediaType = 'voice';[m
[32m+[m[32m      } else if (videoExts.includes(fileExt)) {[m
[32m+[m[32m        finalMediaType = 'video';[m
[32m+[m[32m      } else if (fileExts.includes(fileExt)) {[m
[32m+[m[32m        finalMediaType = 'file';[m
[32m+[m[32m      } else {[m
[32m+[m[32m        finalMediaType = 'file';[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    log?.debug?.([m
[32m+[m[32m      `[DingTalk] uploadMedia called - mediaPath: ${mediaPath}, mediaType: ${mediaType}, finalMediaType: ${finalMediaType}, fileExt: ${fileExt}`[m
[32m+[m[32m    );[m
[32m+[m
[32m+[m[32m    const token = await getAccessToken(config, log);[m
[32m+[m[32m    log?.debug?.(`[DingTalk] Access token obtained for media upload`);[m
[32m+[m
[32m+[m[32m    if (!fs.existsSync(mediaPath)) {[m
[32m+[m[32m      if (log?.error) {[m
[32m+[m[32m        log.error(`[DingTalk] File not found: ${mediaPath}`);[m
[32m+[m[32m      }[m
[32m+[m[32m      return null;[m
[32m+[m[32m    }[m
[32m+[m[32m    log?.debug?.(`[DingTalk] File exists: ${mediaPath}`);[m
[32m+[m
[32m+[m[32m    const fileStats = fs.statSync(mediaPath);[m
[32m+[m[32m    const fileSize = fileStats.size;[m
[32m+[m
[32m+[m[32m    // æ–‡ä»¶å¤§å°é™åˆ¶æ£€æŸ¥ï¼ˆæ ¹æ®é’‰é’‰APIæœ€æ–°è§„èŒƒï¼š2025å¹´ï¼‰[m
[32m+[m[32m    const sizeLimits: Record<string, number> = {[m
[32m+[m[32m      image: 2 * 1024 * 1024, // 2MB[m
[32m+[m[32m      voice: 2 * 1024 * 1024, // 2MB[m
[32m+[m[32m      video: 100 * 1024 * 1024, // 100MB[m
[32m+[m[32m      file: 20 * 1024 * 1024, // 20MB[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    const limit = sizeLimits[finalMediaType] || 20 * 1024 * 1024;[m
[32m+[m[32m    if (fileSize > limit) {[m
[32m+[m[32m      log?.error?.(`[DingTalk] File size ${fileSize} bytes exceeds limit ${limit} bytes for type ${finalMediaType}`);[m
[32m+[m[32m      return null;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    log?.debug?.(`[DingTalk] File stats - fileName: ${fileName}, fileSize: ${fileSize} bytes, limit: ${limit} bytes`);[m
[32m+[m
[32m+[m[32m    // é’‰é’‰æœ€æ–°APIè§„èŒƒï¼šä½¿ç”¨ FormData ä¸Šä¼ ï¼Œå­—æ®µåå¿…é¡»æ˜¯ 'media'[m
[32m+[m[32m    const formData = new FormData();[m
[32m+[m[32m    formData.append('media', fs.createReadStream(mediaPath), {[m
[32m+[m[32m      filename: fileName,[m
[32m+[m[32m      contentType: 'application/octet-stream',[m
[32m+[m[32m    } as any);[m
[32m+[m[32m    log?.debug?.(`[DingTalk] FormData created with media field`);[m
[32m+[m
[32m+[m[32m    // é’‰é’‰æœ€æ–°APIè§„èŒƒï¼ˆ2025å¹´ï¼‰ï¼š[m
[32m+[m[32m    // - ä½¿ç”¨ oapi.dingtalk.com åŸŸå[m
[32m+[m[32m    // - access_token å’Œ type éƒ½åœ¨ query string ä¸­[m
[32m+[m[32m    // - ä¸è¦æ‰‹åŠ¨è®¾ç½® Content-Typeï¼Œè®© axios è‡ªåŠ¨ç”Ÿæˆ boundary[m
[32m+[m[32m    const uploadUrl = `https://oapi.dingtalk.com/media/upload?access_token=${token}&type=${finalMediaType}`;[m
[32m+[m[32m    log?.debug?.(`[DingTalk] Starting upload to: https://oapi.dingtalk.com/media/upload [with query params]`);[m
[32m+[m
[32m+[m[32m    const response = await axios.post<{[m
[32m+[m[32m      media_id?: string;[m
[32m+[m[32m      errcode?: number;[m
[32m+[m[32m      errmsg?: string;[m
[32m+[m[32m      type?: string;[m
[32m+[m[32m      created_at?: number;[m
[32m+[m[32m    }>(uploadUrl, formData, {[m
[32m+[m[32m      // ä¸è¦æ‰‹åŠ¨è®¾ç½® headersï¼Œè®© axios æ ¹æ® FormData è‡ªåŠ¨ç”Ÿæˆ multipart/form-data å’Œ boundary[m
[32m+[m[32m      maxBodyLength: Math.max(fileSize * 2, 100 * 1024), // 2å€æ–‡ä»¶å¤§å°æˆ–100KBï¼Œå–è¾ƒå¤§å€¼ï¼ˆå°æ–‡ä»¶å…ƒæ•°æ®å¯èƒ½å¾ˆå¤§ï¼‰[m
[32m+[m[32m      timeout: 120000, // 120ç§’è¶…æ—¶ï¼Œé€‚åº”å¤§æ–‡ä»¶ä¸Šä¼ [m
[32m+[m[32m    });[m
[32m+[m
[32m+[m[32m    log?.debug?.(`[DingTalk] Upload response status: ${response.status}`);[m
[32m+[m[32m    log?.debug?.(`[DingTalk] Upload response data: ${JSON.stringify(response.data)}`);[m
[32m+[m
[32m+[m[32m    // é’‰é’‰APIå“åº”è§„èŒƒï¼šerrcode ä¸º 0 è¡¨ç¤ºæˆåŠŸ[m
[32m+[m[32m    if (response.data?.errcode === 0 && response.data?.media_id) {[m
[32m+[m[32m      log?.info?.([m
[32m+[m[32m        `[DingTalk] File uploaded successfully - media_id: ${response.data.media_id}, type: ${response.data.type}`[m
[32m+[m[32m      );[m
[32m+[m[32m      return {[m
[32m+[m[32m        mediaId: response.data.media_id,[m
[32m+[m[32m        type: response.data.type || finalMediaType,[m
[32m+[m[32m        createdAt: new Date((response.data.created_at || Date.now()) * 1000).toISOString(), // created_at æ˜¯ç§’çº§æ—¶é—´æˆ³[m
[32m+[m[32m      };[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (response.data?.errcode) {[m
[32m+[m[32m      log?.error?.(`[DingTalk] Upload failed with errcode: ${response.data.errcode}, errmsg: ${response.data.errmsg}`);[m
[32m+[m[32m    } else {[m
[32m+[m[32m      log?.error?.(`[DingTalk] Upload response missing media_id - data: ${JSON.stringify(response.data)}`);[m
[32m+[m[32m    }[m
[32m+[m[32m    return null;[m
[32m+[m[32m  } catch (err: any) {[m
[32m+[m[32m    log?.error?.(`[DingTalk] Failed to upload media - message: ${err.message}`);[m
[32m+[m[32m    log?.error?.([m
[32m+[m[32m      `[DingTalk] Upload error details: ${JSON.stringify({[m
[32m+[m[32m        message: err.message,[m
[32m+[m[32m        code: err.code,[m
[32m+[m[32m        status: err.response?.status,[m
[32m+[m[32m        statusText: err.response?.statusText,[m
[32m+[m[32m        data: err.response?.data,[m
[32m+[m[32m      })}`[m
[32m+[m[32m    );[m
[32m+[m[32m    if (log?.debug) {[m
[32m+[m[32m      log.debug(`[DingTalk] Upload error stack: ${err.stack}`);[m
[32m+[m[32m    }[m
[32m+[m[32m    return null;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
 function extractMessageContent(data: DingTalkInboundMessage): MessageContent {[m
   const msgtype = data.msgtype || 'text';[m
 [m
[36m@@ -338,12 +478,102 @@[m [masync function sendBySession([m
   config: DingTalkConfig,[m
   sessionWebhook: string,[m
   text: string,[m
[31m-  options: SendMessageOptions = {}[m
[32m+[m[32m  options?: SendMessageOptions[m
[32m+[m[32m): Promise<AxiosResponse>;[m
[32m+[m[32masync function sendBySession([m
[32m+[m[32m  config: DingTalkConfig,[m
[32m+[m[32m  sessionWebhook: string,[m
[32m+[m[32m  text: string,[m
[32m+[m[32m  mediaPath: string,[m
[32m+[m[32m  options?: SendMessageOptions[m
[32m+[m[32m): Promise<AxiosResponse>;[m
[32m+[m[32masync function sendBySession([m
[32m+[m[32m  config: DingTalkConfig,[m
[32m+[m[32m  sessionWebhook: string,[m
[32m+[m[32m  text: string,[m
[32m+[m[32m  textOrMediaPath?: string | SendMessageOptions,[m
[32m+[m[32m  optionsOrMediaPath?: SendMessageOptions | string,[m
[32m+[m[32m  mediaPathOption?: SendMessageOptions[m
 ): Promise<AxiosResponse> {[m
[31m-  const token = await getAccessToken(config, options.log);[m
[31m-  [m
[31m-  // Use shared helper function for markdown detection and title extraction[m
[32m+[m[32m  const initialLog =[m
[32m+[m[32m    typeof textOrMediaPath === 'object'[m
[32m+[m[32m      ? textOrMediaPath.log[m
[32m+[m[32m      : typeof optionsOrMediaPath === 'object'[m
[32m+[m[32m        ? optionsOrMediaPath.log[m
[32m+[m[32m        : undefined;[m
[32m+[m
[32m+[m[32m  initialLog?.info?.(`[DingTalk] sendBySession called - sessionWebhook: ${sessionWebhook}`);[m
[32m+[m[32m  initialLog?.debug?.([m
[32m+[m[32m    `[DingTalk] sendBySession parameters - text: ${text}, textOrMediaPath type: ${typeof textOrMediaPath}, optionsOrMediaPath type: ${typeof optionsOrMediaPath}`[m
[32m+[m[32m  );[m
[32m+[m
[32m+[m[32m  const token = await getAccessToken(config, initialLog);[m
[32m+[m
[32m+[m[32m  let mediaPath: string | undefined;[m
[32m+[m[32m  let options: SendMessageOptions = {};[m
[32m+[m
[32m+[m[32m  if (typeof textOrMediaPath === 'object') {[m
[32m+[m[32m    options = textOrMediaPath;[m
[32m+[m[32m    options.log?.debug?.(`[DingTalk] sendBySession - textOrMediaPath is SendMessageOptions`);[m
[32m+[m[32m  } else if (typeof textOrMediaPath === 'string') {[m
[32m+[m[32m    mediaPath = textOrMediaPath;[m
[32m+[m[32m    options.log?.debug?.(`[DingTalk] sendBySession - textOrMediaPath is string (mediaPath): ${mediaPath}`);[m
[32m+[m[32m    if (typeof optionsOrMediaPath === 'object') {[m
[32m+[m[32m      options = optionsOrMediaPath;[m
[32m+[m[32m      options.log?.debug?.(`[DingTalk] sendBySession - optionsOrMediaPath is SendMessageOptions`);[m
[32m+[m[32m    } else if (typeof optionsOrMediaPath === 'string') {[m
[32m+[m[32m      mediaPath = optionsOrMediaPath;[m
[32m+[m[32m      options = mediaPathOption || {};[m
[32m+[m[32m      options.log?.debug?.(`[DingTalk] sendBySession - optionsOrMediaPath is string (mediaPath): ${mediaPath}`);[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  if (mediaPath) {[m
[32m+[m[32m    options.log?.info?.(`[DingTalk] sendBySession - Sending file via session webhook`);[m
[32m+[m[32m    options.log?.debug?.(`[DingTalk] sendBySession - mediaPath: ${mediaPath}, sessionWebhook: ${sessionWebhook}`);[m
[32m+[m
[32m+[m[32m    const uploadResult = await uploadMedia(config, mediaPath, 'file', options.log);[m
[32m+[m[32m    if (!uploadResult) {[m
[32m+[m[32m      options.log?.error?.(`[DingTalk] sendBySession - Failed to upload media file`);[m
[32m+[m[32m      throw new Error('[DingTalk] Failed to upload media file');[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    options.log?.info?.(`[DingTalk] sendBySession - File uploaded successfully, mediaId: ${uploadResult.mediaId}`);[m
[32m+[m
[32m+[m[32m    const fileName = path.basename(mediaPath);[m
[32m+[m[32m    const fileExt = fileName.split('.').pop()?.toLowerCase() || '';[m
[32m+[m[32m    options.log?.debug?.(`[DingTalk] sendBySession - fileName: ${fileName}, fileExt: ${fileExt}`);[m
[32m+[m
[32m+[m[32m    const body: FileMessageWebhookResponse = {[m
[32m+[m[32m      msgtype: 'file',[m
[32m+[m[32m      file: {[m
[32m+[m[32m        fileName,[m
[32m+[m[32m        mediaId: uploadResult.mediaId,[m
[32m+[m[32m        fileType: fileExt,[m
[32m+[m[32m      },[m
[32m+[m[32m    };[m
[32m+[m[32m    if (options.atUserId) body.at = { atUserIds: [options.atUserId], isAtAll: false };[m
[32m+[m
[32m+[m[32m    options.log?.debug?.(`[DingTalk] sendBySession - Request body: ${JSON.stringify(body)}`);[m
[32m+[m
[32m+[m[32m    const result = await axios({[m
[32m+[m[32m      url: sessionWebhook,[m
[32m+[m[32m      method: 'POST',[m
[32m+[m[32m      data: body,[m
[32m+[m[32m      headers: { 'x-acs-dingtalk-access-token': token, 'Content-Type': 'application/json' },[m
[32m+[m[32m    });[m
[32m+[m
[32m+[m[32m    options.log?.info?.(`[DingTalk] sendBySession - File message sent via session webhook`);[m
[32m+[m[32m    options.log?.debug?.(`[DingTalk] sendBySession - Response: ${JSON.stringify(result.data)}`);[m
[32m+[m
[32m+[m[32m    return result.data;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  options.log?.info?.(`[DingTalk] sendBySession - Sending text/markdown message via session webhook`);[m
[32m+[m[32m  options.log?.debug?.(`[DingTalk] sendBySession - text length: ${text.length}`);[m
[32m+[m
   const { useMarkdown, title } = detectMarkdownAndExtractTitle(text, options, 'Clawdbot æ¶ˆæ¯');[m
[32m+[m[32m  options.log?.debug?.(`[DingTalk] sendBySession - useMarkdown: ${useMarkdown}, title: ${title}`);[m
 [m
   let body: SessionWebhookResponse;[m
   if (useMarkdown) {[m
[36m@@ -356,12 +586,91 @@[m [masync function sendBySession([m
 [m
   if (options.atUserId) body.at = { atUserIds: [options.atUserId], isAtAll: false };[m
 [m
[32m+[m[32m  options.log?.debug?.(`[DingTalk] sendBySession - Request body: ${JSON.stringify(body)}`);[m
[32m+[m
   const result = await axios({[m
     url: sessionWebhook,[m
     method: 'POST',[m
     data: body,[m
     headers: { 'x-acs-dingtalk-access-token': token, 'Content-Type': 'application/json' },[m
   });[m
[32m+[m
[32m+[m[32m  options.log?.info?.(`[DingTalk] sendBySession - Message sent successfully`);[m
[32m+[m[32m  options.log?.debug?.(`[DingTalk] sendBySession - Response: ${JSON.stringify(result.data)}`);[m
[32m+[m
[32m+[m[32m  return result.data;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Send file message via proactive API[m
[32m+[m[32masync function sendFileMessage([m
[32m+[m[32m  config: DingTalkConfig,[m
[32m+[m[32m  target: string,[m
[32m+[m[32m  mediaPath: string,[m
[32m+[m[32m  log?: Logger[m
[32m+[m[32m): Promise<AxiosResponse> {[m
[32m+[m[32m  log?.info?.(`[DingTalk] sendFileMessage called - target: ${target}, mediaPath: ${mediaPath}`);[m
[32m+[m[32m  log?.debug?.(`[DingTalk] sendFileMessage config - robotCode: ${config.robotCode}, clientId: ${config.clientId}`);[m
[32m+[m
[32m+[m[32m  log?.info?.(`[DingTalk] Step 1: Uploading media file...`);[m
[32m+[m[32m  const uploadResult = await uploadMedia(config, mediaPath, 'file', log);[m
[32m+[m
[32m+[m[32m  if (!uploadResult) {[m
[32m+[m[32m    log?.error?.(`[DingTalk] sendFileMessage failed - upload returned null`);[m
[32m+[m[32m    throw new Error('[DingTalk] Failed to upload media file');[m
[32m+[m[32m  }[m
[32m+[m[32m  log?.info?.(`[DingTalk] Step 1: Upload successful - mediaId: ${uploadResult.mediaId}`);[m
[32m+[m
[32m+[m[32m  const token = await getAccessToken(config, log);[m
[32m+[m[32m  const isGroup = target.startsWith('cid');[m
[32m+[m[32m  log?.info?.(`[DingTalk] Step 2: Determining target type - isGroup: ${isGroup}`);[m
[32m+[m
[32m+[m[32m  const fileName = path.basename(mediaPath);[m
[32m+[m[32m  const fileExt = fileName.split('.').pop()?.toLowerCase() || '';[m
[32m+[m[32m  log?.debug?.(`[DingTalk] File name extracted: ${fileName}, extension: ${fileExt}`);[m
[32m+[m
[32m+[m[32m  const url = isGroup[m
[32m+[m[32m    ? 'https://api.dingtalk.com/v1.0/robot/groupMessages/send'[m
[32m+[m[32m    : 'https://api.dingtalk.com/v1.0/robot/oToMessages/batchSend';[m
[32m+[m[32m  log?.debug?.(`[DingTalk] API URL selected: ${url}`);[m
[32m+[m
[32m+[m[32m  const payload: ProactiveMessagePayload = {[m
[32m+[m[32m    robotCode: config.robotCode || config.clientId,[m
[32m+[m[32m    msgKey: 'sampleFile',[m
[32m+[m[32m    msgParam: JSON.stringify({[m
[32m+[m[32m      fileName,[m
[32m+[m[32m      mediaId: uploadResult.mediaId,[m
[32m+[m[32m      fileType: fileExt,[m
[32m+[m[32m    }),[m
[32m+[m[32m  };[m
[32m+[m
[32m+[m[32m  if (isGroup) {[m
[32m+[m[32m    (payload as any).openConversationId = target;[m
[32m+[m[32m  } else {[m
[32m+[m[32m    (payload as any).userIds = [target];[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  log?.debug?.([m
[32m+[m[32m    `[DingTalk] Request payload: ${JSON.stringify({[m
[32m+[m[32m      robotCode: payload.robotCode,[m
[32m+[m[32m      msgKey: payload.msgKey,[m
[32m+[m[32m      msgParam: payload.msgParam,[m
[32m+[m[32m      ...(isGroup[m
[32m+[m[32m        ? { openConversationId: (payload as any).openConversationId }[m
[32m+[m[32m        : { userIds: (payload as any).userIds }),[m
[32m+[m[32m    })}`[m
[32m+[m[32m  );[m
[32m+[m[32m  log?.info?.(`[DingTalk] Step 3: Sending file message to DingTalk API...`);[m
[32m+[m
[32m+[m[32m  const result = await axios({[m
[32m+[m[32m    url,[m
[32m+[m[32m    method: 'POST',[m
[32m+[m[32m    data: payload,[m
[32m+[m[32m    headers: { 'x-acs-dingtalk-access-token': token, 'Content-Type': 'application/json' },[m
[32m+[m[32m  });[m
[32m+[m
[32m+[m[32m  log?.info?.(`[DingTalk] Step 3: File message sent successfully`);[m
[32m+[m[32m  log?.debug?.(`[DingTalk] API response - status: ${result.status}, data: ${JSON.stringify(result.data)}`);[m
[32m+[m
   return result.data;[m
 }[m
 [m
[36m@@ -380,13 +689,13 @@[m [masync function sendInteractiveCard([m
 [m
   const token = await getAccessToken(config, options.log);[m
   const isGroup = conversationId.startsWith('cid');[m
[31m-  [m
[32m+[m
   // Generate unique card business ID using crypto.randomUUID[m
   const cardBizId = `card_${randomUUID()}`;[m
[31m-  [m
[32m+[m
   // Extract title and detect markdown[m
   const { useMarkdown, title } = detectMarkdownAndExtractTitle(text, options, 'Clawdbot æ¶ˆæ¯');[m
[31m-  [m
[32m+[m
   // Build card data structure with markdown support[m
   const cardData: InteractiveCardData = {[m
     config: {[m
[36m@@ -406,7 +715,7 @@[m [masync function sendInteractiveCard([m
       },[m
     ],[m
   };[m
[31m-  [m
[32m+[m
   // Build request payload[m
   const payload: InteractiveCardSendRequest = {[m
     cardTemplateId: config.cardTemplateId || 'StandardCard',[m
[36m@@ -414,17 +723,16 @@[m [masync function sendInteractiveCard([m
     robotCode,[m
     cardData: JSON.stringify(cardData),[m
   };[m
[31m-  [m
[32m+[m
   if (isGroup) {[m
     payload.openConversationId = conversationId;[m
   } else {[m
     payload.singleChatReceiver = JSON.stringify({ userId: conversationId });[m
   }[m
[31m-  [m
[32m+[m
   // Use configurable API URL with retry logic[m
[31m-  const apiUrl =[m
[31m-    config.cardSendApiUrl || 'https://api.dingtalk.com/v1.0/im/v1.0/robot/interactiveCards/send';[m
[31m-  [m
[32m+[m[32m  const apiUrl = config.cardSendApiUrl || 'https://api.dingtalk.com/v1.0/im/v1.0/robot/interactiveCards/send';[m
[32m+[m
   const result = await retryWithBackoff([m
     async () => {[m
       return await axios({[m
[36m@@ -436,7 +744,7 @@[m [masync function sendInteractiveCard([m
     },[m
     { maxRetries: 3, log: options.log }[m
   );[m
[31m-  [m
[32m+[m
   // Cache card instance for future updates[m
   cardInstances.set(cardBizId, {[m
     cardBizId,[m
[36m@@ -444,7 +752,7 @@[m [masync function sendInteractiveCard([m
     createdAt: Date.now(),[m
     lastUpdated: Date.now(),[m
   });[m
[31m-  [m
[32m+[m
   return { cardBizId, response: result.data };[m
 }[m
 [m
[36m@@ -456,10 +764,10 @@[m [masync function updateInteractiveCard([m
   options: SendMessageOptions = {}[m
 ): Promise<any> {[m
   const token = await getAccessToken(config, options.log);[m
[31m-  [m
[32m+[m
   // Extract title and detect markdown[m
   const { useMarkdown, title } = detectMarkdownAndExtractTitle(text, options, 'Clawdbot æ¶ˆæ¯');[m
[31m-  [m
[32m+[m
   // Build updated card data with markdown support[m
   const cardData: InteractiveCardData = {[m
     config: {[m
[36m@@ -479,7 +787,7 @@[m [masync function updateInteractiveCard([m
       },[m
     ],[m
   };[m
[31m-  [m
[32m+[m
   // Build update request[m
   const payload: InteractiveCardUpdateRequest = {[m
     cardBizId,[m
[36m@@ -488,10 +796,10 @@[m [masync function updateInteractiveCard([m
       updateCardDataByKey: false,[m
     },[m
   };[m
[31m-  [m
[32m+[m
   // Use configurable API URL with retry logic[m
   const apiUrl = config.cardUpdateApiUrl || 'https://api.dingtalk.com/v1.0/im/robots/interactiveCards';[m
[31m-  [m
[32m+[m
   try {[m
     const result = await retryWithBackoff([m
       async () => {[m
[36m@@ -504,21 +812,19 @@[m [masync function updateInteractiveCard([m
       },[m
       { maxRetries: 3, log: options.log }[m
     );[m
[31m-    [m
[32m+[m
     // Update cache on success[m
     const instance = cardInstances.get(cardBizId);[m
     if (instance) {[m
       instance.lastUpdated = Date.now();[m
     }[m
[31m-    [m
[32m+[m
     return result.data;[m
   } catch (err: any) {[m
     // Remove card from cache on terminal errors (404, 410, etc.)[m
     const statusCode = err.response?.status;[m
     if (statusCode === 404 || statusCode === 410 || statusCode === 403) {[m
[31m-      options.log?.debug?.([m
[31m-        `[DingTalk] Removing card ${cardBizId} from cache due to error ${statusCode}`[m
[31m-      );[m
[32m+[m[32m      options.log?.debug?.(`[DingTalk] Removing card ${cardBizId} from cache due to error ${statusCode}`);[m
       cardInstances.delete(cardBizId);[m
     }[m
     throw err;[m
[36m@@ -535,24 +841,24 @@[m [masync function updateInteractiveCardThrottled([m
   const now = Date.now();[m
   const lastUpdate = cardUpdateTimestamps.get(cardBizId) || 0;[m
   const timeSinceLastUpdate = now - lastUpdate;[m
[31m-  [m
[32m+[m
   // Clear any existing timeout for this card[m
   const existingTimeout = cardUpdateTimeouts.get(cardBizId);[m
   if (existingTimeout) {[m
     clearTimeout(existingTimeout);[m
   }[m
[31m-  [m
[32m+[m
   // If enough time has passed, update immediately[m
   if (timeSinceLastUpdate >= CARD_UPDATE_MIN_INTERVAL) {[m
     cardUpdateTimestamps.set(cardBizId, now);[m
     const result = await updateInteractiveCard(config, cardBizId, text, options);[m
[31m-    [m
[32m+[m
     // Set timeout to detect when updates are complete[m
     const timeout = setTimeout(() => {[m
       cardUpdateTimeouts.delete(cardBizId);[m
       options.log?.debug?.(`[DingTalk] Card ${cardBizId} finalized after inactivity timeout`);[m
     }, CARD_UPDATE_TIMEOUT);[m
[31m-    [m
[32m+[m
     cardUpdateTimeouts.set(cardBizId, timeout);[m
     return result;[m
   } else {[m
[36m@@ -563,20 +869,20 @@[m [masync function updateInteractiveCardThrottled([m
         try {[m
           cardUpdateTimestamps.set(cardBizId, Date.now());[m
           const result = await updateInteractiveCard(config, cardBizId, text, options);[m
[31m-          [m
[32m+[m
           // Set inactivity timeout[m
           const inactivityTimeout = setTimeout(() => {[m
             cardUpdateTimeouts.delete(cardBizId);[m
             options.log?.debug?.(`[DingTalk] Card ${cardBizId} finalized after inactivity timeout`);[m
           }, CARD_UPDATE_TIMEOUT);[m
[31m-          [m
[32m+[m
           cardUpdateTimeouts.set(cardBizId, inactivityTimeout);[m
           resolve(result);[m
         } catch (err) {[m
           reject(err);[m
         }[m
       }, delay);[m
[31m-      [m
[32m+[m
       cardUpdateTimeouts.set(cardBizId, timeout);[m
     });[m
   }[m
[36m@@ -589,33 +895,62 @@[m [masync function sendMessage([m
   text: string,[m
   options: SendMessageOptions & { cardBizId?: string; sessionWebhook?: string } = {}[m
 ): Promise<{ ok: boolean; cardBizId?: string; error?: string }> {[m
[32m+[m[32m  options.log?.info?.(`[DingTalk] sendMessage called - conversationId: ${conversationId}, textLength: ${text.length}`);[m
[32m+[m[32m  options.log?.debug?.([m
[32m+[m[32m    `[DingTalk] sendMessage config - messageType: ${config.messageType}, hasSessionWebhook: ${!!options.sessionWebhook}`[m
[32m+[m[32m  );[m
[32m+[m[32m  options.log?.debug?.([m
[32m+[m[32m    `[DingTalk] sendMessage options - cardBizId: ${options.cardBizId || 'none'}, atUserId: ${options.atUserId || 'none'}`[m
[32m+[m[32m  );[m
[32m+[m
   try {[m
     const messageType = config.messageType || 'markdown';[m
[31m-    [m
[32m+[m[32m    options.log?.debug?.(`[DingTalk] sendMessage determined messageType: ${messageType}`);[m
[32m+[m
     // If sessionWebhook is provided, use session-based sending (for replies during conversation)[m
     if (options.sessionWebhook) {[m
[32m+[m[32m      options.log?.info?.(`[DingTalk] sendMessage using session-based sending via sendBySession`);[m
[32m+[m[32m      options.log?.debug?.(`[DingTalk] sendMessage sessionWebhook: ${options.sessionWebhook}`);[m
       await sendBySession(config, options.sessionWebhook, text, options);[m
[32m+[m[32m      options.log?.info?.(`[DingTalk] sendMessage session-based send completed successfully`);[m
       return { ok: true };[m
     }[m
[31m-    [m
[32m+[m
     // For card mode with streaming[m
     if (messageType === 'card') {[m
[32m+[m[32m      options.log?.info?.(`[DingTalk] sendMessage using card mode`);[m
       if (options.cardBizId) {[m
[31m-        // Update existing card[m
[32m+[m[32m        options.log?.info?.(`[DingTalk] sendMessage updating existing card - cardBizId: ${options.cardBizId}`);[m
         await updateInteractiveCard(config, options.cardBizId, text, options);[m
[32m+[m[32m        options.log?.info?.(`[DingTalk] sendMessage card updated successfully`);[m
         return { ok: true, cardBizId: options.cardBizId };[m
       } else {[m
[31m-        // Create new card[m
[32m+[m[32m        options.log?.info?.(`[DingTalk] sendMessage creating new card`);[m
         const { cardBizId } = await sendInteractiveCard(config, conversationId, text, options);[m
[32m+[m[32m        options.log?.info?.(`[DingTalk] sendMessage new card created - cardBizId: ${cardBizId}`);[m
         return { ok: true, cardBizId };[m
       }[m
     }[m
[31m-    [m
[32m+[m
     // For text/markdown mode (backward compatibility)[m
[32m+[m[32m    options.log?.info?.(`[DingTalk] sendMessage using ${messageType} mode via sendProactiveMessage`);[m
     await sendProactiveMessage(config, conversationId, text, options);[m
[32m+[m[32m    options.log?.info?.(`[DingTalk] sendMessage ${messageType} sent successfully`);[m
     return { ok: true };[m
   } catch (err: any) {[m
[31m-    options.log?.error?.(`[DingTalk] Send message failed: ${err.message}`);[m
[32m+[m[32m    options.log?.error?.(`[DingTalk] sendMessage failed: ${err.message}`);[m
[32m+[m[32m    options.log?.error?.([m
[32m+[m[32m      `[DingTalk] sendMessage error details: ${JSON.stringify({[m
[32m+[m[32m        message: err.message,[m
[32m+[m[32m        code: err.code,[m
[32m+[m[32m        status: err.response?.status,[m
[32m+[m[32m        statusText: err.response?.statusText,[m
[32m+[m[32m        data: err.response?.data,[m
[32m+[m[32m      })}`[m
[32m+[m[32m    );[m
[32m+[m[32m    if (options.log?.debug) {[m
[32m+[m[32m      options.log.debug(`[DingTalk] sendMessage error stack: ${err.stack}`);[m
[32m+[m[32m    }[m
     return { ok: false, error: err.message };[m
   }[m
 }[m
[36m@@ -625,16 +960,26 @@[m [masync function handleDingTalkMessage(params: HandleDingTalkMessageParams): Promi[m
   const { cfg, accountId, data, sessionWebhook, log, dingtalkConfig } = params;[m
   const rt = getDingTalkRuntime();[m
 [m
[32m+[m[32m  log?.info?.(`[DingTalk] handleDingTalkMessage called - accountId: ${accountId}, msgId: ${data.msgId || 'unknown'}`);[m
[32m+[m[32m  log?.debug?.(`[DingTalk] handleDingTalkMessage sessionWebhook: ${sessionWebhook || 'none'}`);[m
   log?.debug?.('[DingTalk] Full Inbound Data:', JSON.stringify(maskSensitiveData(data)));[m
 [m
   // 1. è¿‡æ»¤æœºå™¨äººè‡ªèº«æ¶ˆæ¯[m
[32m+[m[32m  log?.debug?.(`[DingTalk] Checking self-message - senderId: ${data.senderId}, chatbotUserId: ${data.chatbotUserId}`);[m
   if (data.senderId === data.chatbotUserId || data.senderStaffId === data.chatbotUserId) {[m
[31m-    log?.debug?.('[DingTalk] Ignoring robot self-message');[m
[32m+[m[32m    log?.info?.('[DingTalk] Ignoring robot self-message');[m
     return;[m
   }[m
[32m+[m[32m  log?.debug?.('[DingTalk] Message is not from robot itself');[m
 [m
   const content = extractMessageContent(data);[m
[31m-  if (!content.text) return;[m
[32m+[m[32m  log?.info?.(`[DingTalk] Message extracted - type: ${content.messageType}, hasText: ${!!content.text}`);[m
[32m+[m[32m  log?.debug?.(`[DingTalk] Message content: "${content.text?.slice(0, 100)}..."`);[m
[32m+[m
[32m+[m[32m  if (!content.text) {[m
[32m+[m[32m    log?.warn?.('[DingTalk] No text content in message, skipping');[m
[32m+[m[32m    return;[m
[32m+[m[32m  }[m
 [m
   const isDirect = data.conversationType === '1';[m
   const senderId = data.senderStaffId || data.senderId;[m
[36m@@ -642,65 +987,99 @@[m [masync function handleDingTalkMessage(params: HandleDingTalkMessageParams): Promi[m
   const groupId = data.conversationId;[m
   const groupName = data.conversationTitle || 'Group';[m
 [m
[32m+[m[32m  log?.info?.(`[DingTalk] Message context - isDirect: ${isDirect}, senderId: ${senderId}, senderName: ${senderName}`);[m
[32m+[m[32m  log?.debug?.(`[DingTalk] Group info - groupId: ${groupId}, groupName: ${groupName}`);[m
[32m+[m
   // 2. Check authorization for direct messages based on dmPolicy[m
   let commandAuthorized = true;[m
   if (isDirect) {[m
     const dmPolicy = dingtalkConfig.dmPolicy || 'open';[m
     const allowFrom = dingtalkConfig.allowFrom || [];[m
[31m-    [m
[32m+[m
[32m+[m[32m    log?.info?.(`[DingTalk] DM policy check - dmPolicy: ${dmPolicy}, allowFrom count: ${allowFrom.length}`);[m
[32m+[m
     if (dmPolicy === 'allowlist') {[m
       const normalizedAllowFrom = normalizeAllowFrom(allowFrom);[m
       const isAllowed = isSenderAllowed({ allow: normalizedAllowFrom, senderId });[m
[31m-      [m
[32m+[m
[32m+[m[32m      log?.debug?.(`[DingTalk] Allowlist check - senderId: ${senderId}, isAllowed: ${isAllowed}`);[m
[32m+[m
       if (!isAllowed) {[m
[31m-        log?.debug?.(`[DingTalk] DM blocked: senderId=${senderId} not in allowlist (dmPolicy=allowlist)`);[m
[31m-        [m
[32m+[m[32m        log?.info?.(`[DingTalk] DM blocked: senderId=${senderId} not in allowlist (dmPolicy=allowlist)`);[m
[32m+[m
         // Notify user with their sender ID so they can request access[m
         try {[m
[31m-          await sendBySession(dingtalkConfig, sessionWebhook, [m
[31m-            `â›” è®¿é—®å—é™\n\næ‚¨çš„ç”¨æˆ·IDï¼š\`${senderId}\`\n\nè¯·è”ç³»ç®¡ç†å‘˜å°†æ­¤IDæ·»åŠ åˆ°å…è®¸åˆ—è¡¨ä¸­ã€‚`, [m
[32m+[m[32m          log?.info?.('[DingTalk] Sending access denied notification');[m
[32m+[m[32m          await sendBySession([m
[32m+[m[32m            dingtalkConfig,[m
[32m+[m[32m            sessionWebhook,[m
[32m+[m[32m            `â›” è®¿é—®å—é™\n\næ‚¨çš„ç”¨æˆ·IDï¼š\`${senderId}\`\n\nè¯·è”ç³»ç®¡ç†å‘˜å°†æ­¤IDæ·»åŠ åˆ°å…è®¸åˆ—è¡¨ä¸­ã€‚`,[m
             { log }[m
           );[m
[32m+[m[32m          log?.info?.('[DingTalk] Access denied notification sent successfully');[m
         } catch (err: any) {[m
[31m-          log?.debug?.(`[DingTalk] Failed to send access denied message: ${err.message}`);[m
[32m+[m[32m          log?.error?.(`[DingTalk] Failed to send access denied message: ${err.message}`);[m
         }[m
[31m-        [m
[32m+[m
         return;[m
       }[m
[31m-      [m
[31m-      log?.debug?.(`[DingTalk] DM authorized: senderId=${senderId} in allowlist`);[m
[32m+[m
[32m+[m[32m      log?.info?.(`[DingTalk] DM authorized: senderId=${senderId} in allowlist`);[m
     } else if (dmPolicy === 'pairing') {[m
[31m-      // For pairing mode, SDK will handle the authorization[m
[31m-      // Set commandAuthorized to true to let SDK check pairing status[m
[32m+[m[32m      log?.info?.('[DingTalk] DM policy is pairing, SDK will handle authorization');[m
       commandAuthorized = true;[m
     } else {[m
[31m-      // 'open' policy - allow all[m
[32m+[m[32m      log?.info?.('[DingTalk] DM policy is open, allowing all messages');[m
       commandAuthorized = true;[m
     }[m
   }[m
 [m
[32m+[m[32m  // 3. Handle media files[m
   let mediaPath: string | undefined;[m
   let mediaType: string | undefined;[m
   if (content.mediaPath && dingtalkConfig.robotCode) {[m
[32m+[m[32m    log?.info?.([m
[32m+[m[32m      `[DingTalk] Received media message - downloadCode: ${content.mediaPath}, messageType: ${content.messageType}`[m
[32m+[m[32m    );[m
[32m+[m[32m    log?.debug?.(`[DingTalk] Downloading media with robotCode: ${dingtalkConfig.robotCode}`);[m
     const media = await downloadMedia(dingtalkConfig, content.mediaPath, log);[m
     if (media) {[m
       mediaPath = media.path;[m
       mediaType = media.mimeType;[m
[32m+[m[32m      log?.info?.(`[DingTalk] Media downloaded successfully - path: ${mediaPath}, mimeType: ${mediaType}`);[m
[32m+[m[32m    } else {[m
[32m+[m[32m      log?.warn?.(`[DingTalk] Failed to download media - downloadCode: ${content.mediaPath}`);[m
     }[m
[32m+[m[32m  } else {[m
[32m+[m[32m    log?.debug?.([m
[32m+[m[32m      `[DingTalk] No media to download - hasMediaPath: ${!!content.mediaPath}, hasRobotCode: ${!!dingtalkConfig.robotCode}`[m
[32m+[m[32m    );[m
   }[m
 [m
[32m+[m[32m  // 4. Resolve agent route[m
[32m+[m[32m  log?.info?.('[DingTalk] Resolving agent route...');[m
   const route = rt.channel.routing.resolveAgentRoute({[m
     cfg,[m
     channel: 'dingtalk',[m
     accountId,[m
     peer: { kind: isDirect ? 'dm' : 'group', id: isDirect ? senderId : groupId },[m
   });[m
[32m+[m[32m  log?.info?.(`[DingTalk] Agent route resolved - agentId: ${route.agentId}, sessionKey: ${route.sessionKey}`);[m
[32m+[m[32m  log?.debug?.(`[DingTalk] Route details - mainSessionKey: ${route.mainSessionKey}`);[m
 [m
   const storePath = rt.channel.session.resolveStorePath(cfg.session?.store, { agentId: route.agentId });[m
[32m+[m[32m  log?.debug?.(`[DingTalk] Session store path: ${storePath}`);[m
[32m+[m
   const envelopeOptions = rt.channel.reply.resolveEnvelopeFormatOptions(cfg);[m
[32m+[m[32m  log?.debug?.(`[DingTalk] Envelope options: ${JSON.stringify(envelopeOptions)}`);[m
[32m+[m
   const previousTimestamp = rt.channel.session.readSessionUpdatedAt({ storePath, sessionKey: route.sessionKey });[m
[32m+[m[32m  log?.debug?.(`[DingTalk] Previous session timestamp: ${previousTimestamp || 'none'}`);[m
 [m
[32m+[m[32m  // 5. Format inbound envelope[m
   const fromLabel = isDirect ? `${senderName} (${senderId})` : `${groupName} - ${senderName}`;[m
[32m+[m[32m  log?.debug?.(`[DingTalk] From label: ${fromLabel}`);[m
[32m+[m
   const body = rt.channel.reply.formatInboundEnvelope({[m
     channel: 'DingTalk',[m
     from: fromLabel,[m
[36m@@ -711,8 +1090,13 @@[m [masync function handleDingTalkMessage(params: HandleDingTalkMessageParams): Promi[m
     previousTimestamp,[m
     envelope: envelopeOptions,[m
   });[m
[32m+[m[32m  log?.debug?.(`[DingTalk] Inbound envelope formatted`);[m
 [m
   const to = isDirect ? senderId : groupId;[m
[32m+[m[32m  log?.debug?.(`[DingTalk] Target (to): ${to}`);[m
[32m+[m
[32m+[m[32m  // 6. Finalize context[m
[32m+[m[32m  log?.info?.('[DingTalk] Finalizing inbound context...');[m
   const ctx = rt.channel.reply.finalizeInboundContext({[m
     Body: body,[m
     RawBody: content.text,[m
[36m@@ -737,67 +1121,129 @@[m [masync function handleDingTalkMessage(params: HandleDingTalkMessageParams): Promi[m
     OriginatingChannel: 'dingtalk',[m
     OriginatingTo: to,[m
   });[m
[32m+[m[32m  log?.info?.(`[DingTalk] Inbound context finalized - SessionKey: ${ctx.SessionKey}`);[m
 [m
[32m+[m[32m  // 7. Record session[m
[32m+[m[32m  log?.info?.('[DingTalk] Recording inbound session...');[m
   await rt.channel.session.recordInboundSession({[m
     storePath,[m
     sessionKey: ctx.SessionKey || route.sessionKey,[m
     ctx,[m
     updateLastRoute: { sessionKey: route.mainSessionKey, channel: 'dingtalk', to, accountId },[m
   });[m
[32m+[m[32m  log?.info?.('[DingTalk] Inbound session recorded successfully');[m
 [m
   log?.info?.(`[DingTalk] Inbound: from=${senderName} text="${content.text.slice(0, 50)}..."`);[m
 [m
[31m-  // Feedback: Thinking...[m
[32m+[m[32m  // 8. Send "thinking" feedback[m
   let currentCardBizId: string | undefined;[m
   const useCardMode = dingtalkConfig.messageType === 'card';[m
[31m-  [m
[32m+[m
[32m+[m[32m  log?.info?.([m
[32m+[m[32m    `[DingTalk] Reply mode - useCardMode: ${useCardMode}, showThinking: ${dingtalkConfig.showThinking !== false}`[m
[32m+[m[32m  );[m
[32m+[m
   if (dingtalkConfig.showThinking !== false) {[m
[32m+[m[32m    log?.info?.('[DingTalk] Sending "thinking" message...');[m
     try {[m
       if (useCardMode) {[m
[31m-        // For card mode, send initial card with thinking message[m
[32m+[m[32m        log?.info?.('[DingTalk] Sending thinking card...');[m
         const result = await sendInteractiveCard(dingtalkConfig, to, 'ğŸ¤” æ€è€ƒä¸­ï¼Œè¯·ç¨å€™...', { log });[m
         currentCardBizId = result.cardBizId;[m
[32m+[m[32m        log?.info?.(`[DingTalk] Thinking card sent - cardBizId: ${currentCardBizId}`);[m
       } else {[m
[31m-        // For text/markdown mode, send via session webhook[m
[32m+[m[32m        log?.info?.('[DingTalk] Sending thinking message via session webhook...');[m
         await sendBySession(dingtalkConfig, sessionWebhook, 'ğŸ¤” æ€è€ƒä¸­ï¼Œè¯·ç¨å€™...', {[m
           atUserId: !isDirect ? senderId : null,[m
           log,[m
         });[m
[32m+[m[32m        log?.info?.('[DingTalk] Thinking message sent successfully');[m
       }[m
     } catch (err: any) {[m
[31m-      log?.debug?.(`[DingTalk] Thinking message failed: ${err.message}`);[m
[32m+[m[32m      log?.error?.(`[DingTalk] Thinking message failed: ${err.message}`);[m
[32m+[m[32m      log?.debug?.(`[DingTalk] Thinking message error: ${err.stack}`);[m
     }[m
   }[m
 [m
[32m+[m[32m  // 9. Create reply dispatcher[m
[32m+[m[32m  log?.info?.('[DingTalk] Creating reply dispatcher...');[m
   const { dispatcher, replyOptions, markDispatchIdle } = rt.channel.reply.createReplyDispatcherWithTyping({[m
     responsePrefix: '',[m
     deliver: async (payload: any) => {[m
       try {[m
[32m+[m[32m        log?.debug?.(`[DingTalk] Deliver payload received: ${JSON.stringify(payload)}`);[m
         const textToSend = payload.markdown || payload.text;[m
[31m-        if (!textToSend) return { ok: true };[m
[31m-        [m
[31m-        if (useCardMode) {[m
[31m-          // Card mode: update existing card or create new one (throttled)[m
[31m-          if (currentCardBizId) {[m
[31m-            await updateInteractiveCard(dingtalkConfig, currentCardBizId, textToSend, { log });[m
[32m+[m[32m        log?.debug?.(`[DingTalk] Deliver called - textLength: ${textToSend?.length || 0}`);[m
[32m+[m
[32m+[m[32m        // Check for media files (single or multiple)[m
[32m+[m[32m        const hasMediaUrls = payload.mediaUrls && Array.isArray(payload.mediaUrls) && payload.mediaUrls.length > 0;[m
[32m+[m[32m        const hasMediaUrl = payload.mediaUrl && typeof payload.mediaUrl === 'string';[m
[32m+[m
[32m+[m[32m        log?.debug?.(`[DingTalk] Media check - hasMediaUrls: ${hasMediaUrls}, hasMediaUrl: ${hasMediaUrl}`);[m
[32m+[m
[32m+[m[32m        // Send media files first if present[m
[32m+[m[32m        if (hasMediaUrls) {[m
[32m+[m[32m          log?.info?.(`[DingTalk] Sending ${payload.mediaUrls.length} media file(s) from mediaUrls`);[m
[32m+[m[32m          for (const mediaUrl of payload.mediaUrls) {[m
[32m+[m[32m            try {[m
[32m+[m[32m              log?.info?.(`[DingTalk] Sending media file: ${mediaUrl}`);[m
[32m+[m[32m              await sendFileMessage(dingtalkConfig, to, mediaUrl, log);[m
[32m+[m[32m              log?.info?.(`[DingTalk] Media file sent successfully: ${mediaUrl}`);[m
[32m+[m[32m            } catch (err: any) {[m
[32m+[m[32m              log?.error?.(`[DingTalk] Failed to send media file ${mediaUrl}: ${err.message}`);[m
[32m+[m[32m              // Continue sending other files even if one fails[m
[32m+[m[32m            }[m
[32m+[m[32m          }[m
[32m+[m[32m        } else if (hasMediaUrl) {[m
[32m+[m[32m          log?.info?.(`[DingTalk] Sending single media file from mediaUrl: ${payload.mediaUrl}`);[m
[32m+[m[32m          try {[m
[32m+[m[32m            await sendFileMessage(dingtalkConfig, to, payload.mediaUrl, log);[m
[32m+[m[32m            log?.info?.(`[DingTalk] Media file sent successfully: ${payload.mediaUrl}`);[m
[32m+[m[32m          } catch (err: any) {[m
[32m+[m[32m            log?.error?.(`[DingTalk] Failed to send media file ${payload.mediaUrl}: ${err.message}`);[m
[32m+[m[32m          }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Then send text message if present[m
[32m+[m[32m        if (textToSend) {[m
[32m+[m[32m          log?.info?.('[DingTalk] Sending text message');[m
[32m+[m[32m          if (useCardMode) {[m
[32m+[m[32m            log?.info?.(`[DingTalk] Delivering via card mode - hasCardBizId: ${!!currentCardBizId}`);[m
[32m+[m[32m            if (currentCardBizId) {[m
[32m+[m[32m              log?.debug?.(`[DingTalk] Updating existing card - cardBizId: ${currentCardBizId}`);[m
[32m+[m[32m              await updateInteractiveCard(dingtalkConfig, currentCardBizId, textToSend, { log });[m
[32m+[m[32m              log?.debug?.('[DingTalk] Card updated successfully');[m
[32m+[m[32m            } else {[m
[32m+[m[32m              log?.info?.('[DingTalk] Creating new card for delivery');[m
[32m+[m[32m              const result = await sendInteractiveCard(dingtalkConfig, to, textToSend, { log });[m
[32m+[m[32m              currentCardBizId = result.cardBizId;[m
[32m+[m[32m              log?.info?.(`[DingTalk] New card created - cardBizId: ${currentCardBizId}`);[m
[32m+[m[32m            }[m
           } else {[m
[31m-            const result = await sendInteractiveCard(dingtalkConfig, to, textToSend, { log });[m
[31m-            currentCardBizId = result.cardBizId;[m
[32m+[m[32m            log?.info?.('[DingTalk] Delivering via session webhook');[m
[32m+[m[32m            await sendBySession(dingtalkConfig, sessionWebhook, textToSend, {[m
[32m+[m[32m              atUserId: !isDirect ? senderId : null,[m
[32m+[m[32m              log,[m
[32m+[m[32m            });[m
[32m+[m[32m            log?.debug?.('[DingTalk] Message delivered via session webhook');[m
           }[m
[31m-        } else {[m
[31m-          // Text/markdown mode: send via session webhook[m
[31m-          await sendBySession(dingtalkConfig, sessionWebhook, textToSend, {[m
[31m-            atUserId: !isDirect ? senderId : null,[m
[31m-            log,[m
[31m-          });[m
         }[m
[32m+[m
         return { ok: true };[m
       } catch (err: any) {[m
[31m-        log?.error?.(`[DingTalk] Reply failed: ${err.message}`);[m
[32m+[m[32m        log?.error?.(`[DingTalk] Reply delivery failed: ${err.message}`);[m
[32m+[m[32m        log?.error?.([m
[32m+[m[32m          `[DingTalk] Delivery error details: ${JSON.stringify({[m
[32m+[m[32m            message: err.message,[m
[32m+[m[32m            code: err.code,[m
[32m+[m[32m            status: err.response?.status,[m
[32m+[m[32m          })}`[m
[32m+[m[32m        );[m
         return { ok: false, error: err.message };[m
       }[m
     },[m
   });[m
[32m+[m[32m  log?.info?.('[DingTalk] Reply dispatcher created successfully');[m
 [m
   try {[m
     await rt.channel.reply.dispatchReplyFromConfig({ ctx, cfg, dispatcher, replyOptions });[m
[36m@@ -896,15 +1342,38 @@[m [mexport const dingtalkPlugin = {[m
       }[m
     },[m
     sendMedia: async ({ cfg, to, mediaPath, accountId, log }: any) => {[m
[32m+[m[32m      log?.info?.(`[DingTalk] outbound.sendMedia called - to: ${to}, mediaPath: ${mediaPath}, accountId: ${accountId}`);[m
[32m+[m
       const config = getConfig(cfg, accountId);[m
       if (!config.clientId) {[m
[32m+[m[32m        log?.error?.(`[DingTalk] outbound.sendMedia - clientId not configured`);[m
         return { ok: false, error: 'DingTalk not configured' };[m
       }[m
[32m+[m[32m      log?.debug?.([m
[32m+[m[32m        `[DingTalk] outbound.sendMedia - Config found - clientId: ${config.clientId}, robotCode: ${config.robotCode}`[m
[32m+[m[32m      );[m
[32m+[m
       try {[m
[31m-        const mediaDescription = `[åª’ä½“æ¶ˆæ¯: ${mediaPath}]`;[m
[31m-        const result = await sendProactiveMessage(config, to, mediaDescription, { log });[m
[32m+[m[32m        log?.info?.(`[DingTalk] outbound.sendMedia - Calling sendFileMessage...`);[m
[32m+[m[32m        const result = await sendFileMessage(config, to, mediaPath, log);[m
[32m+[m[32m        log?.info?.(`[DingTalk] outbound.sendMedia - File sent successfully`);[m
[32m+[m[32m        log?.debug?.(`[DingTalk] outbound.sendMedia - Result: ${JSON.stringify(result)}`);[m
         return { ok: true, data: result };[m
       } catch (err: any) {[m
[32m+[m[32m        log?.error?.(`[DingTalk] outbound.sendMedia - Failed to send file`);[m
[32m+[m[32m        log?.error?.(`[DingTalk] outbound.sendMedia - Error: ${err.message}`);[m
[32m+[m[32m        log?.error?.([m
[32m+[m[32m          `[DingTalk] outbound.sendMedia - Error details: ${JSON.stringify({[m
[32m+[m[32m            message: err.message,[m
[32m+[m[32m            code: err.code,[m
[32m+[m[32m            status: err.response?.status,[m
[32m+[m[32m            statusText: err.response?.statusText,[m
[32m+[m[32m            data: err.response?.data,[m
[32m+[m[32m          })}`[m
[32m+[m[32m        );[m
[32m+[m[32m        if (log?.debug) {[m
[32m+[m[32m          log.debug(`[DingTalk] outbound.sendMedia - Error stack: ${err.stack}`);[m
[32m+[m[32m        }[m
         return { ok: false, error: err.response?.data || err.message };[m
       }[m
     },[m
[36m@@ -1005,9 +1474,11 @@[m [mexport const dingtalkPlugin = {[m
  * Public low-level API exports for the DingTalk channel plugin.[m
  *[m
  * - {@link sendBySession} sends a message to DingTalk using a session/webhook[m
[31m- *   (e.g. replies within an existing conversation).[m
[32m+[m[32m *   (e.g. replies within an existing conversation). Supports text, markdown, and file messages.[m
  * - {@link sendProactiveMessage} sends a proactive/outbound message to DingTalk[m
  *   without requiring an existing inbound session.[m
[32m+[m[32m * - {@link sendFileMessage} sends a file message to DingTalk.[m
[32m+[m[32m * - {@link uploadMedia} uploads a media file to DingTalk and returns mediaId.[m
  * - {@link sendInteractiveCard} sends an interactive card to DingTalk[m
  *   (returns cardBizId for streaming updates).[m
  * - {@link updateInteractiveCard} updates an existing interactive card[m
[36m@@ -1025,6 +1496,8 @@[m [mexport const dingtalkPlugin = {[m
 export {[m
   sendBySession,[m
   sendProactiveMessage,[m
[32m+[m[32m  sendFileMessage,[m
[32m+[m[32m  uploadMedia,[m
   sendInteractiveCard,[m
   updateInteractiveCard,[m
   updateInteractiveCardThrottled,[m
[1mdiff --git a/src/types.ts b/src/types.ts[m
[1mindex c46f958..9d31be7 100644[m
[1m--- a/src/types.ts[m
[1m+++ b/src/types.ts[m
[36m@@ -11,6 +11,15 @@[m
 [m
 import type { OpenClawConfig } from 'openclaw/plugin-sdk';[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * Upload media file request parameters[m
[32m+[m[32m */[m
[32m+[m[32mexport interface UploadMediaParams {[m
[32m+[m[32m  type: 'image' | 'video' | 'audio' | 'file';[m
[32m+[m[32m  mediaPath: string;[m
[32m+[m[32m  agentId?: string;[m
[32m+[m[32m}[m
[32m+[m
 /**[m
  * DingTalk channel configuration (extends base OpenClaw config)[m
  */[m
[36m@@ -98,6 +107,36 @@[m [mexport interface MediaFile {[m
   mimeType: string;[m
 }[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * Media upload response from DingTalk API[m
[32m+[m[32m */[m
[32m+[m[32mexport interface MediaUploadResponse {[m
[32m+[m[32m  mediaId: string;[m
[32m+[m[32m  type?: string;[m
[32m+[m[32m  createdAt?: string;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * File message content for sending files[m
[32m+[m[32m */[m
[32m+[m[32mexport interface FileMessageContent {[m
[32m+[m[32m  fileName: string;[m
[32m+[m[32m  mediaId: string;[m
[32m+[m[32m  fileType: string;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Session webhook response with file message[m
[32m+[m[32m */[m
[32m+[m[32mexport interface FileMessageWebhookResponse {[m
[32m+[m[32m  msgtype: 'file';[m
[32m+[m[32m  file: FileMessageContent;[m
[32m+[m[32m  at?: {[m
[32m+[m[32m    atUserIds: string[];[m
[32m+[m[32m    isAtAll: boolean;[m
[32m+[m[32m  };[m
[32m+[m[32m}[m
[32m+[m
 /**[m
  * DingTalk incoming message (Stream mode)[m
  */[m
